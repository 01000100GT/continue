# 代码库索引

这是一个小型 Rust 库，用于高效地保持代码库索引的最新状态。

### 工作原理

> 重要定义：_标签_是唯一标识索引的（工作区、分支、provider_id）三元组。由于我们在索引中使用基于内容的寻址，大部分数据为了效率而被共享。

sync_results 函数的输出是包含 4 个元组列表的列表。每个元组包含一个文件路径和文件内容的哈希值。这 4 个列表是：

1. 计算（Compute）：需要新计算或更新的文件
2. 删除（Delete）：需要从索引中删除的文件
3. 添加标签（Add label）：存在于索引中但需要为新标签添加标签的文件
4. 删除标签（Remove label）：存在于索引中但需要删除标签的文件

标签帮助我们在从像 Meilisearch 或 Chroma 这样的索引中检索结果时进行过滤。这些索引中项目的所有 ID 都是文件内容的哈希值（可能在末尾加上块索引）。

第一次时，会构建代码库文件夹的默克尔树（Merkle tree），忽略 .gitignore 或 .continueignore 中的任何文件。找到的每个文件都将被返回为需要计算并添加到索引中。

此后，将执行以下步骤：

1. 加载标签的先前计算的默克尔树
2. 计算代码库的当前默克尔树
3. 使用当前时间戳更新 .last_sync 文件
4. 将新树保存到磁盘
5. 计算树的差异，告诉您哪些文件已被 a) 添加或 b) 删除
6. 对于每个添加的文件：
   - 如果在全局缓存中，将其追加到 `add_label`
   - 否则，将其追加到 `compute`
7. 对于每个删除的文件：
   - 如果在全局缓存中，但仅在此标签的 rev_tags 中，将其追加到 `delete`
   - 如果在全局缓存中存在于多个标签，将其追加到 `remove_label`
   - 否则，忽略。这种情况不应该发生。
8. 返回 (compute, delete, add_label, remove_label)

### 创建的文件

在 ~/.continue/index 文件夹中存储和更新了几个文件，以跟踪已索引的文件：

- `~/.continue/index/tags/<dir>/<branch>/<provider_id>/merkle_tree` - 给定标签的代码库的最后计算的默克尔树
- `~/.continue/index/tags/<dir>/<branch>/<provider_id>/.last_sync` - 标签上次同步的时间
- 索引缓存包含已经在一般情况下和每个标签中计算过的哈希列表。这些总是保持同步。
  - `~/.continue/index/.index_cache` - 包含全局缓存（哈希的平面文件）
  - `~/.continue/index/tags/<dir>/<branch>/<provider_id>/.index_cache` - 包含特定标签的缓存（哈希的平面文件）
  - `~/.continue/index/rev_tags` - 包含从哈希到当前为哈希索引的标签的映射。这是一个文件目录，其中每个文件都以哈希的前 2 个字符为前缀。该文件是从哈希到标签列表的 JSON 映射。

### 文件

- `lib.rs` 包含仅由 Python 绑定调用的顶层函数
- `sync/merkle.rs` 包含默克尔树的实现（用于构建和比较树）
- `sync/mod.rs` 包含主要的同步逻辑，处理维护哪些哈希包含在哪些标签中的磁盘数据库

### 当前限制：

- 仅处理本地文件，因此目前不用于 Continue 服务器与 IDE 或工作区位于不同机器上的情况（远程 SSH、WSL 或为团队运行的 Continue 服务器）。
- 目前没有使用 stat 来检查文件的最近更改，而是在每次 IDE 重新加载时重新计算整个默克尔树。目前这没问题，因为在 Continue 代码库上只需要 0.2 秒，但这是我们以后可以做的快速改进。 
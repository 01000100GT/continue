# 代码库索引

这是一个小型 Rust 库，用于高效地保持代码库索引的更新。

### 工作原理

> 重要定义：_标签_是唯一标识索引的（工作区，分支，提供者ID）三元组。由于我们在索引内使用基于内容的寻址，为了效率，大部分数据是共享的。

sync_results 函数的输出是一个包含 4 个元组列表的列表。每个元组包含一个文件路径和文件内容的哈希值。这 4 个列表是：

1. 计算：需要新计算或更新的文件
2. 删除：需要从索引中删除的文件
3. 添加标签：存在于索引中但需要为新标签添加标签的文件
4. 移除标签：存在于索引中但需要移除标签的文件

这些标签帮助我们在从像 Meilisearch 或 Chroma 这样的索引中检索结果时进行过滤。这些索引中项目的所有 ID 都是文件内容的哈希值（可能在末尾加上块索引）。

第一次运行时，会构建代码库文件夹的默克尔树，忽略 .gitignore 或 .continueignore 中的任何文件。找到的每个文件都将被返回为需要计算并添加到索引中。

此后，执行以下步骤：

1. 加载标签之前计算的默克尔树
2. 计算代码库的当前默克尔树
3. 使用当前时间戳更新 .last_sync 文件
4. 将新树保存到磁盘
5. 计算树的差异，告诉你哪些文件被 a) 添加或 b) 移除
6. 对于每个添加的文件：
   - 如果在全局缓存中，将其追加到 `add_label`
   - 否则，将其追加到 `compute`
7. 对于每个移除的文件：
   - 如果在全局缓存中，但仅在此标签的 rev_tags 中，将其追加到 `delete`
   - 如果在全局缓存中不只为此标签，将其追加到 `remove_label`
   - 否则，忽略。这种情况不应该发生。
8. 返回 (compute, delete, add_label, remove_label)

### 创建的文件

在 ~/.continue/index 文件夹中存储和更新几个文件，以跟踪已索引的文件：

- `~/.continue/index/tags/<dir>/<branch>/<provider_id>/merkle_tree` - 给定标签的代码库最后计算的默克尔树
- `~/.continue/index/tags/<dir>/<branch>/<provider_id>/.last_sync` - 标签最后同步的时间
- 索引缓存包含已在一般情况下和每个标签下计算的哈希列表。这些始终保持同步。
  - `~/.continue/index/.index_cache` - 包含全局缓存（哈希的平面文件）
  - `~/.continue/index/tags/<dir>/<branch>/<provider_id>/.index_cache` - 包含特定标签的缓存（哈希的平面文件）
  - `~/.continue/index/rev_tags` - 包含从哈希到当前为该哈希索引的标签的映射。这是一个文件目录，其中每个文件以哈希的前 2 个字符为前缀。该文件是从哈希到标签列表的 JSON 映射。

### 文件

- `lib.rs` 仅包含由 Python 绑定调用的顶级函数
- `sync/merkle.rs` 包含默克尔树实现（用于构建和比较树）
- `sync/mod.rs` 包含主要的同步逻辑，它处理哪些哈希包含在哪些标签中的磁盘数据库的维护

### 当前限制：

- 仅处理本地文件，因此目前不适用于 Continue 服务器与 IDE 或工作区位于不同机器上的情况（远程 SSH，WSL 或为团队运行的 Continue 服务器）。
- 目前没有使用 stat 检查文件的最近更改，而是在每次 IDE 重新加载时重新计算整个默克尔树。目前这样做还可以，因为在 Continue 代码库上只需 0.2 秒，但这是我们以后可以进行的快速改进。 
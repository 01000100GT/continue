# 索引

Continue 使用标签系统和内容寻址确保无需对任何内容进行两次索引。当您切换分支时，Continue 只会重新索引那些新修改的且我们还没有副本的文件。通过实现 `CodebaseIndex` 类，这个系统可以用于许多不同的"工件"。

_工件_：通过索引生成并保存以供以后使用的东西（例如，嵌入向量、全文搜索索引或每个文件中顶级代码片段的表格）

_cacheKey_：一个键，用于确定两个文件是否可以被视为相同以避免重新索引（目前总是文件内容的哈希值）

_`CodebaseIndex`_：一个类，它使使用索引系统帮助您生成新工件变得容易

索引过程执行以下操作：

1. 检查仓库中所有文件的修改时间戳（这可能看起来很极端，但检查时间戳比实际读取文件要快得多。Git 也是这样做的。）
2. 将这些与"目录"（存储在 SQLite 中）进行比较，该目录记录了我们上次索引这些文件的时间，以获取需要"添加"或"删除"的文件列表。如果文件存在于仓库中但不在目录中，那么我们必须"添加"该文件。如果它存在于目录中但不在仓库中，我们必须"删除"该文件。如果它同时存在于两者中且在上次索引后被修改，那么我们必须更新该文件。在这种情况下，我们也将其添加到"添加"列表中。
3. 对于每个要"添加"的文件，检查它是否在另一个分支上被索引过。这里我们使用一个 SQLite 表作为已索引文件的缓存。如果我们在该表中找到一个具有相同 cacheKey 的文件条目，那么我们只需要为当前分支添加一个标签到这个条目（"addTag"）。否则，我们必须"计算"工件。
4. 对于"删除"列表中的每个文件，检查它是否在另一个分支上被索引过。如果我们只找到一个具有相同 cacheKey 的条目（通常这应该是当前分支的条目，否则就出错了），那么应该删除这个条目，并且将不再有任何分支需要这个工件，所以我们要"删除"它。如果这个工件上有多个标签，那么我们应该只删除这个分支的标签（"removeTag"）。
5. 在计算出这四个文件列表（"compute"、"delete"、"addTag"、"removeTag"）后，我们将它们传递给 `CodebaseIndex`，以便它可以更新它可能拥有的任何特定于索引的存储。许多索引使用 SQLite 和/或 LanceDB。`CodebaseIndex` 实现了一个名为"update"的方法，它接受这四个列表并在迭代这些列表时产生进度更新。这些进度更新用于正式标记文件已被索引，这样如果扩展在索引过程中关闭，我们就不会错误地记录进度。

## 现有的 `CodebaseIndex` 实现

如果要使用所有索引，它们必须由 [`CodebaseIndexer.ts`](./CodebaseIndexer.ts) 中的 `getIndexesToBuild` 返回。

`CodeSnippetsCodebaseIndex`：使用 tree-sitter 查询获取每个文件中的函数、类和其他顶级代码对象列表
`FullTextSearchCodebaseIndex`：使用 SQLite FTS5 创建全文搜索索引
`ChunkCodebaseIndex`：根据代码结构递归地分块文件，用于其他嵌入提供者，如 `LanceDbCodebaseIndex`
`LanceDbCodebaseIndex`：计算每个块的嵌入并将它们添加到 LanceDB 向量数据库，元数据进入 SQLite。请注意，对于每个分支，在 LanceDB 中都会创建一个唯一的表。

## 已知问题

- `FullTextSearchCodebaseIndex` 不区分标签（分支、仓库），因此结果可能来自任何分支/仓库。LanceDB 通过为每个标签创建单独的表来实现这一点（参见 `tableNameForTag`）。块索引通过第二个表来实现这一点 
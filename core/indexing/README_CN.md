# 索引

Continue 使用标记系统和内容寻址来确保不需要对任何内容进行两次索引。当你切换分支时，Continue 只会对新修改的且我们还没有副本的文件重新建立索引。这个系统可以通过实现 `CodebaseIndex` 类在许多不同的"构件"中使用。

_构件_：通过索引生成并保存以供以后使用的东西（例如，嵌入、全文搜索索引或每个文件中顶级代码片段的表格）

_cacheKey_：一个键，用于确定两个文件是否可以被视为相同以避免重新索引（目前始终是文件内容的哈希值）

_`CodebaseIndex`_：一个类，它使使用索引系统帮助你生成新构件变得容易

索引过程执行以下操作：

1. 检查存储库中所有文件的修改时间戳（这看起来可能很极端，但检查时间戳比实际读取文件要快得多。Git 也是这样做的。）
2. 将这些与"目录"（存储在 SQLite 中）进行比较，该目录记录了我们上次对这些文件建立索引的时间，以获取要"添加"或"删除"的文件列表。如果文件存在于存储库中但不在目录中，那么我们必须"添加"该文件。如果它存在于目录中但不在存储库中，我们必须"删除"该文件。如果两者都存在，并且在最后索引后进行了修改，那么我们必须更新该文件。在这种情况下，我们也将其添加到"添加"列表中。
3. 对于要"添加"的每个文件，检查它是否在另一个分支上建立了索引。在这里，我们使用充当已索引文件缓存的 SQLite 表。如果我们在此表中找到具有相同 cacheKey 的文件条目，那么我们只需要为当前分支向此条目添加标记（"addTag"）。否则，我们必须"计算"构件。
4. 对于"删除"中的每个文件，检查它是否在另一个分支上建立了索引。如果我们只找到一个具有相同 cacheKey 的条目（假设这应该是当前分支的条目，否则就出了问题），那么该条目应该被删除，并且不会有更多分支需要该构件，所以我们要"删除"它。如果此构件上有多个标记，则我们应该只删除此分支的标记（"removeTag"）。
5. 在计算了这四个文件列表（"compute"、"delete"、"addTag"、"removeTag"）之后，我们将它们传递给 `CodebaseIndex`，以便它可以更新可能拥有的任何特定于索引的存储。许多索引使用 SQLite 和/或 LanceDB。`CodebaseIndex` 实现了一个名为"update"的方法，该方法接受四个列表并在迭代列表时生成进度更新。这些进度更新用于正式标记文件已被索引，以便如果扩展在索引过程中关闭，我们不会错误地记录进度。

## 现有的 `CodebaseIndex`

所有索引必须由 [`CodebaseIndexer.ts`](./CodebaseIndexer.ts) 中的 `getIndexesToBuild` 返回才能使用。

`CodeSnippetsCodebaseIndex`：使用 tree-sitter 查询获取每个文件中的函数、类和其他顶级代码对象列表
`FullTextSearchCodebaseIndex`：使用 SQLite FTS5 创建全文搜索索引
`ChunkCodebaseIndex`：通过代码结构递归地分块文件，用于其他嵌入提供者，如 `LanceDbCodebaseIndex`
`LanceDbCodebaseIndex`：计算每个块的嵌入并将它们添加到 LanceDB 向量数据库中，元数据进入 SQLite。注意，对于每个分支，在 LanceDB 中创建一个唯一的表。

## 已知问题

- `FullTextSearchCodebaseIndex` 不区分标记（分支、存储库），因此结果可能来自任何分支/存储库。LanceDB 通过为每个标记创建单独的表来实现这一点（参见 `tableNameForTag`）。块索引通过第二个表来做到这一点 